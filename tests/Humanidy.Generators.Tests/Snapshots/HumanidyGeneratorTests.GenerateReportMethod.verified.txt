// <auto-generated/>

#nullable enable

namespace Humanidy.Generators.Sample;

/// <summary>
/// An identifier of the form <c>pref_</c> followed by 14 random alphanumeric ASCII characters.
/// <remarks>
/// SampleEntity has an entropy of ~83.36 bits.
/// </remarks>
/// </summary>
// [global::System.Text.Json.Serialization.JsonConverter(typeof(global::Humanidy.Text.Json.SampleEntityJsonConverter))]
readonly partial struct SampleEntity :
   global::System.IEquatable<SampleEntity>,
   global::System.IComparable<SampleEntity>,
   global::System.ISpanFormattable,
   global::System.ISpanParsable<SampleEntity>,
   global::System.IUtf8SpanFormattable,
   global::System.IUtf8SpanParsable<SampleEntity>
{
    private const int MaxRandomLength = 256;
    private const int RandomLength = 14;
    private const int PrefixLength = 4;
    
    private static global::System.ReadOnlySpan<byte> ValidIdBytes => "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"u8;
    
    private static global::System.ReadOnlySpan<byte> Prefix => "pref"u8;
    
    /// <summary>
    /// The length of the identifier when not empty.
    /// </summary>
    public const int Length = PrefixLength + RandomLength;

    private readonly global::System.ReadOnlyMemory<byte> _value;
    
    private SampleEntity(global::System.ReadOnlyMemory<byte> value)
    {
        _value = value;
    }
    
    /// <summary>
    /// Creates a new, randomly generated, SampleEntity with the prefix <c>pref</c> and 14 random alphanumeric ASCII characters.
    /// </summary>
    public static SampleEntity NewId()
    {
        global::System.Memory<byte> buffer = new byte[Length];
        
        Prefix.CopyTo(buffer.Span);
        buffer.Span[PrefixLength] = (byte)'_';

        global::System.Security.Cryptography.RandomNumberGenerator.GetItems(ValidIdBytes, buffer.Span[(PrefixLength + 1)..]);

        return new(buffer);
    }
        
    public bool Equals(SampleEntity other)
    {
        return global::System.MemoryExtensions.SequenceEqual(_value.Span, other._value.Span);
    }
    
    public override bool Equals(object? obj)
    {
        return obj is SampleEntity identifier && Equals(identifier);
    }
    
    public override int GetHashCode()
    {
        var c = new global::System.HashCode();
        c.AddBytes(_value.Span);
        return c.ToHashCode();
    }
    
    public static bool operator ==(SampleEntity left, SampleEntity right)
    {
        return left.Equals(right);
    }
    
    public static bool operator !=(SampleEntity left, SampleEntity right)
    {
        return !(left == right);
    }

    public int CompareTo(SampleEntity other)
    {
        return global::System.MemoryExtensions.SequenceCompareTo(_value.Span, other._value.Span);
    }
    
    public static bool operator <(SampleEntity left, SampleEntity right)
    {
        return left.CompareTo(right) < 0;
    }
    
    public static bool operator <=(SampleEntity left, SampleEntity right)
    {
        return left.CompareTo(right) <= 0;
    }
    
    public static bool operator >(SampleEntity left, SampleEntity right)
    {
        return left.CompareTo(right) > 0;
    }
    
    public static bool operator >=(SampleEntity left, SampleEntity right)
    {
        return left.CompareTo(right) >= 0;
    }
    
    # region IParsable<SampleEntity>
    
    public static SampleEntity Parse(string s)
    {
        global::System.ArgumentNullException.ThrowIfNull(s);
        return Parse(global::System.MemoryExtensions.AsSpan(s));
    }

    static SampleEntity global::System.IParsable<SampleEntity>.Parse(string s, global::System.IFormatProvider? provider)
    {
        return Parse(s);
    }

    public static bool TryParse(string? s, out SampleEntity result)
    {
        if (s is null)
        {
            result = default;
            return false;
        }

        return TryParse(global::System.MemoryExtensions.AsSpan(s), out result);
    }

    static bool global::System.IParsable<SampleEntity>.TryParse(string? s, global::System.IFormatProvider? provider, out SampleEntity result)
    {
        return TryParse(s, out result);
    }

    # endregion
    
    public override string ToString()
    {
        if (_value.IsEmpty)
        {
            return string.Empty;
        }
        
        return string.Create(Length, this, static (span, @self) =>
        {
            var result = @self.TryFormat(span, out var charsWritten);
            global::System.Diagnostics.Debug.Assert(result);
            global::System.Diagnostics.Debug.Assert(charsWritten == Length);
        });
    }
    
    string global::System.IFormattable.ToString(
        string? format, 
        global::System.IFormatProvider? formatProvider)
    {
        return ToString();
    }

    # region ISpanParsable<SampleEntity>

    public static SampleEntity Parse(global::System.ReadOnlySpan<char> s)
    {
        if (TryParse(s, out var result))
        {
            return result;
        }
        
        throw new global::System.FormatException(
            $"The provided string '{s.ToString()}' is not a valid SampleEntity.");
    }

    static SampleEntity global::System.ISpanParsable<SampleEntity>.Parse(global::System.ReadOnlySpan<char> s, global::System.IFormatProvider? provider)
    {
        return Parse(s);
    }

    public static bool TryParse(global::System.ReadOnlySpan<char> s, out SampleEntity result)
    {
        global::System.Span<byte> buffer = stackalloc byte[512]; // TODO: Better choice of buffer size.

        if (global::System.Text.Ascii.FromUtf16(s, buffer, out var bytesWritten) is global::System.Buffers.OperationStatus.Done)
        {
            return TryParse(buffer[..bytesWritten], out result);
        }

        result = default;
        return false;
    }
   
    static bool global::System.ISpanParsable<SampleEntity>.TryParse(global::System.ReadOnlySpan<char> s, global::System.IFormatProvider? provider, out SampleEntity result)
    {
        return TryParse(s, out result);
    }
   
    # endregion
    
    # region IUtf8SpanParsable<SampleEntity>
    
    public static SampleEntity Parse(global::System.ReadOnlySpan<byte> utf8Text)
    {
        if (TryParse(utf8Text, out var result))
        {
            return result;
        }
       
        throw new global::System.FormatException(
            $"The provided UTF-8 byte span is not a valid SampleEntity.");
    }
    
    static SampleEntity global::System.IUtf8SpanParsable<SampleEntity>.Parse(global::System.ReadOnlySpan<byte> utf8Text, global::System.IFormatProvider? provider)
    {
        return Parse(utf8Text);
    }
    
    public static bool TryParse(global::System.ReadOnlySpan<byte> utf8Text, out SampleEntity result)
    {
        if (utf8Text.Length is not Length || utf8Text[PrefixLength] is not (byte)'_')
        {
            result = default;
            return false;
        }
           
        for (var i = 0; i < PrefixLength; i++)
        {
            if (utf8Text[i] != Prefix[i])
            {
                result = default;
                return false;
            }
        }

        result = new(utf8Text.ToArray());
        return true;
    }
       
    static bool global::System.IUtf8SpanParsable<SampleEntity>.TryParse(global::System.ReadOnlySpan<byte> utf8Text, global::System.IFormatProvider? provider, out SampleEntity result)
    {
        return TryParse(utf8Text, out result);
    }
    
    # endregion
    
    # region ISpanFormattable
    
    public bool TryFormat(
        global::System.Span<char> destination, 
        out int charsWritten)
    {
        if (destination.Length < Length)
        {
            charsWritten = 0;
            return false;
        }

        return global::System.Text.Ascii.ToUtf16(_value.Span, destination, out charsWritten) is global::System.Buffers.OperationStatus.Done;
    }
    
    bool global::System.ISpanFormattable.TryFormat(
        global::System.Span<char> destination, 
        out int charsWritten, 
        global::System.ReadOnlySpan<char> format, 
        global::System.IFormatProvider? provider)
    {
        return TryFormat(destination, out charsWritten);
    }
    
    # endregion
    
    # region IUtf8SpanFormattable
    
    public bool TryFormat(global::System.Span<byte> utf8Destination, out int bytesWritten)
    {
        if (utf8Destination.Length < Length)
        {
            bytesWritten = 0;
            return false;
        }

        _value.Span.CopyTo(utf8Destination);
        bytesWritten = _value.Length;
        return true;
    }
    
    bool global::System.IUtf8SpanFormattable.TryFormat(
        global::System.Span<byte> utf8Destination, 
        out int bytesWritten, 
        global::System.ReadOnlySpan<char> format, 
        global::System.IFormatProvider? provider)
    {
        return TryFormat(utf8Destination, out bytesWritten);
    }
    
    # endregion
}

// <auto-generated/>

#nullable enable

namespace Humanidy.Text.Json;

public sealed class SampleEntityJsonConverter : global::System.Text.Json.Serialization.JsonConverter<global::Humanidy.Generators.Sample.SampleEntity>
{
    public override global::Humanidy.Generators.Sample.SampleEntity Read(ref global::System.Text.Json.Utf8JsonReader reader, global::System.Type typeToConvert, global::System.Text.Json.JsonSerializerOptions options)
    {
        if (reader.TokenType != global::System.Text.Json.JsonTokenType.String)
        {
            throw new global::System.Text.Json.JsonException("Expected a string token.");
        }

        var value = reader.GetString();
       
        if (value is null || !global::Humanidy.Generators.Sample.SampleEntity.TryParse(value, out var result))
        {
            throw new global::System.Text.Json.JsonException($"Invalid global::Humanidy.Generators.Sample.SampleEntity value: {value}");
        }

        return result;
    }

    public override void Write(global::System.Text.Json.Utf8JsonWriter writer, global::Humanidy.Generators.Sample.SampleEntity value, global::System.Text.Json.JsonSerializerOptions options)
    {
        writer.WriteStringValue(value.ToString());
    }
}                   
