using Microsoft.CodeAnalysis.Text;

namespace Humanidy.Generators;

internal static class HumanidyIdentifierEmitter
{
    public static SourceText Emit(IdentifierSpecification spec, HumanidyCompilationOptions options)
    {
        var builder = new SourceWriter();

        builder.WriteBlock("// <auto-generated/>");
        builder.WriteBlock("#nullable enable");

        if (spec.Namespace is not null)
        {
            builder.WriteBlock($"namespace {spec.Namespace};");
        }

        const string alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
        var entropy = EntropyCalculator.Entropy(spec.RandomLength, alphabet.Length);

        builder.WriteLine(
            $$"""
              /// <summary>
              /// An identifier of the form <c>{{spec.Prefix}}_</c> followed by {{spec.RandomLength}} random alphanumeric ASCII characters.
              /// <remarks>
              /// {{spec.StructName}} has an entropy of ~{{entropy:F2}} bits.
              /// </remarks>
              /// </summary>
              readonly partial struct {{spec.StructName}} :
                 global::System.IEquatable<{{spec.StructName}}>,
                 global::System.IComparable<{{spec.StructName}}>,
                 global::System.ISpanFormattable,
                 global::System.ISpanParsable<{{spec.StructName}}>,
                 global::System.IUtf8SpanFormattable,
                 global::System.IUtf8SpanParsable<{{spec.StructName}}>
              {
              """);

        builder.Indentation++;

        _ = builder
            .WriteConstants(spec, alphabet)
            .WriteConstructor(spec)
            .WriteNewIdMethod(spec)
            .WriteComparisonMethods(spec)
            .WriteIParsableImpl(spec)
            .WriteIFormattableImpl()
            .WriteISpanParsableImpl(spec, options)
            .WriteIUtf8SpanParsableImpl(spec)
            .WriteISpanFormattableImpl()
            .WriteIUtf8FormattableImpl();

        builder.Indentation--;
        builder.WriteBlock("}");

        return builder.ToSourceText();
    }

    private static SourceWriter WriteConstructor(this SourceWriter builder, IdentifierSpecification spec)
    {
        builder.WriteBlock(
            $$"""
              /// <summary>
              /// The underlying value of the identifier.
              /// </summary>
              private readonly global::System.ReadOnlyMemory<byte> _value;

              private {{spec.StructName}}(global::System.ReadOnlyMemory<byte> value)
              {
                  _value = value;
              }
              """);

        return builder;
    }

    private static SourceWriter WriteConstants(this SourceWriter builder, IdentifierSpecification spec, string alphabet)
    {
        builder.WriteBlock(
            $"""
             /// <summary>
             /// The length of the randomly generated part of the identifier.
             /// </summary>
             private const int RandomLength = {spec.RandomLength};

             /// <summary>
             /// The length of the prefix, excluding the trailing underscore.
             /// </summary>
             private const int PrefixLength = {spec.Prefix.Length};

             /// <summary>
             /// The valid characters for the random part of the identifier.
             /// </summary>
             private static global::System.ReadOnlySpan<byte> ValidIdBytes => "{alphabet}"u8;

             /// <summary>
             /// The prefix of the identifier, excluding the trailing underscore.
             /// </summary>
             private static global::System.ReadOnlySpan<byte> Prefix => "{spec.Prefix}"u8;

             /// <summary>
             /// The length of the identifier when not empty.
             /// </summary>
             public const int Length = PrefixLength + RandomLength + 1;
             """);

        return builder;
    }

    private static SourceWriter WriteIUtf8FormattableImpl(this SourceWriter builder)
    {
        builder.WriteBlock(
            """
            # region IUtf8SpanFormattable

            public bool TryFormat(global::System.Span<byte> utf8Destination, out int bytesWritten)
            {
                if (utf8Destination.Length < Length)
                {
                    bytesWritten = 0;
                    return false;
                }

                _value.Span.CopyTo(utf8Destination);
                bytesWritten = _value.Length;
                return true;
            }

            bool global::System.IUtf8SpanFormattable.TryFormat(
                global::System.Span<byte> utf8Destination, 
                out int bytesWritten, 
                global::System.ReadOnlySpan<char> format, 
                global::System.IFormatProvider? provider)
            {
                return TryFormat(utf8Destination, out bytesWritten);
            }

            # endregion
            """);

        return builder;
    }

    private static SourceWriter WriteISpanFormattableImpl(this SourceWriter builder)
    {
        builder.WriteBlock(
            """
            # region ISpanFormattable

            public bool TryFormat(
                global::System.Span<char> destination, 
                out int charsWritten)
            {
                if (destination.Length < Length)
                {
                    charsWritten = 0;
                    return false;
                }

                return global::System.Text.Ascii.ToUtf16(_value.Span, destination, out charsWritten) 
                    is global::System.Buffers.OperationStatus.Done;
            }

            bool global::System.ISpanFormattable.TryFormat(
                global::System.Span<char> destination, 
                out int charsWritten, 
                global::System.ReadOnlySpan<char> format, 
                global::System.IFormatProvider? provider)
            {
                return TryFormat(destination, out charsWritten);
            }

            # endregion
            """);

        return builder;
    }

    private static SourceWriter WriteIUtf8SpanParsableImpl(this SourceWriter builder, IdentifierSpecification spec)
    {
        builder.WriteBlock(
            $$"""
              # region IUtf8SpanParsable<{{spec.StructName}}>

              public static {{spec.StructName}} Parse(global::System.ReadOnlySpan<byte> utf8Text)
              {
                  if (TryParse(utf8Text, out var result))
                  {
                      return result;
                  }
                 
                  throw new global::System.FormatException(
                      $"The provided UTF-8 byte span is not a valid {{spec.StructName}}.");
              }

              static {{spec.StructName}} global::System.IUtf8SpanParsable<{{spec.StructName}}>.Parse(
                  global::System.ReadOnlySpan<byte> utf8Text,
                  global::System.IFormatProvider? provider)
              {
                  return Parse(utf8Text);
              }

              public static bool TryParse(global::System.ReadOnlySpan<byte> utf8Text, out {{spec.StructName}} result)
              {
                  if (utf8Text.Length is not Length || utf8Text[PrefixLength] is not (byte)'_')
                  {
                      result = default;
                      return false;
                  }
                     
                  for (var i = 0; i < PrefixLength; i++)
                  {
                      if (utf8Text[i] != Prefix[i])
                      {
                          result = default;
                          return false;
                      }
                  }

                  result = new(utf8Text.ToArray());
                  return true;
              }
                 
              static bool global::System.IUtf8SpanParsable<{{spec.StructName}}>.TryParse(
                  global::System.ReadOnlySpan<byte> utf8Text, 
                  global::System.IFormatProvider? provider, 
                  out {{spec.StructName}} result)
              {
                  return TryParse(utf8Text, out result);
              }

              # endregion
              """);

        return builder;
    }

    private static SourceWriter WriteISpanParsableImpl(
        this SourceWriter builder,
        IdentifierSpecification spec,
        HumanidyCompilationOptions options)
    {
        builder.WriteBlock(
            $$"""
              # region ISpanParsable<{{spec.StructName}}>

              public static {{spec.StructName}} Parse(global::System.ReadOnlySpan<char> s)
              {
                  if (TryParse(s, out var result))
                  {
                      return result;
                  }
                  
                  throw new global::System.FormatException(
                      $"The provided string '{s.ToString()}' is not a valid {{spec.StructName}}.");
              }

              static {{spec.StructName}} global::System.ISpanParsable<{{spec.StructName}}>.Parse(
                  global::System.ReadOnlySpan<char> s, 
                  global::System.IFormatProvider? provider)
              {
                  return Parse(s);
              }
              """);

        builder.WriteSkipLocalsInitAttr(options);

        builder.WriteBlock(
            $$"""
              public static bool TryParse(global::System.ReadOnlySpan<char> s, out {{spec.StructName}} result)
              {
                  global::System.Span<byte> buffer = stackalloc byte[Length];

                  if (global::System.Text.Ascii.FromUtf16(s, buffer, out var bytesWritten) is global::System.Buffers.OperationStatus.Done)
                  {
                      return TryParse(buffer[..bytesWritten], out result);
                  }

                  result = default;
                  return false;
              }

              static bool global::System.ISpanParsable<{{spec.StructName}}>.TryParse(
                  global::System.ReadOnlySpan<char> s,
                  global::System.IFormatProvider? provider,
                  out {{spec.StructName}} result)
              {
                  return TryParse(s, out result);
              }

              # endregion
              """);

        return builder;
    }

    private static SourceWriter WriteIFormattableImpl(this SourceWriter builder)
    {
        builder.WriteBlock(
            """
            public override string ToString()
            {
                if (_value.IsEmpty)
                {
                    return string.Empty;
                }
                
                return string.Create(Length, this, static (span, @self) =>
                {
                    var result = @self.TryFormat(span, out var charsWritten);
                    global::System.Diagnostics.Debug.Assert(result);
                    global::System.Diagnostics.Debug.Assert(charsWritten == Length);
                });
            }

            string global::System.IFormattable.ToString(
                string? format, 
                global::System.IFormatProvider? formatProvider)
            {
                return ToString();
            }
            """);

        return builder;
    }

    private static SourceWriter WriteIParsableImpl(this SourceWriter builder, IdentifierSpecification spec)
    {
        builder.WriteBlock(
            $$"""
              # region IParsable<{{spec.StructName}}>

              public static {{spec.StructName}} Parse(string s)
              {
                  global::System.ArgumentNullException.ThrowIfNull(s);
                  return Parse(global::System.MemoryExtensions.AsSpan(s));
              }

              static {{spec.StructName}} global::System.IParsable<{{spec.StructName}}>.Parse(
                  string s, 
                  global::System.IFormatProvider? provider)
              {
                  return Parse(s);
              }

              public static bool TryParse(string? s, out {{spec.StructName}} result)
              {
                  if (s is null)
                  {
                      result = default;
                      return false;
                  }

                  return TryParse(global::System.MemoryExtensions.AsSpan(s), out result);
              }

              static bool global::System.IParsable<{{spec.StructName}}>.TryParse(
                  string? s, 
                  global::System.IFormatProvider? provider, 
                  out {{spec.StructName}} result)
              {
                  return TryParse(s, out result);
              }

              # endregion
              """);

        return builder;
    }

    private static SourceWriter WriteComparisonMethods(this SourceWriter builder, IdentifierSpecification spec)
    {
        builder.WriteBlock(
            $$"""
              public bool Equals({{spec.StructName}} other)
              {
                  return global::System.MemoryExtensions.SequenceEqual(_value.Span, other._value.Span);
              }

              public override bool Equals(object? obj)
              {
                  return obj is {{spec.StructName}} identifier && Equals(identifier);
              }

              public override int GetHashCode()
              {
                  var hashCode = new global::System.HashCode();
                  hashCode.AddBytes(_value.Span);
                  return hashCode.ToHashCode();
              }

              public static bool operator ==({{spec.StructName}} left, {{spec.StructName}} right)
              {
                  return left.Equals(right);
              }

              public static bool operator !=({{spec.StructName}} left, {{spec.StructName}} right)
              {
                  return !(left == right);
              }

              public int CompareTo({{spec.StructName}} other)
              {
                  return global::System.MemoryExtensions.SequenceCompareTo(_value.Span, other._value.Span);
              }

              public static bool operator <({{spec.StructName}} left, {{spec.StructName}} right)
              {
                  return left.CompareTo(right) < 0;
              }

              public static bool operator <=({{spec.StructName}} left, {{spec.StructName}} right)
              {
                  return left.CompareTo(right) <= 0;
              }

              public static bool operator >({{spec.StructName}} left, {{spec.StructName}} right)
              {
                  return left.CompareTo(right) > 0;
              }

              public static bool operator >=({{spec.StructName}} left, {{spec.StructName}} right)
              {
                  return left.CompareTo(right) >= 0;
              }
              """);

        return builder;
    }

    private static SourceWriter WriteNewIdMethod(this SourceWriter builder, IdentifierSpecification spec)
    {
        builder.WriteBlock(
            $$"""
              /// <summary>
              /// Creates a new, randomly generated, {{spec.StructName}} with the prefix <c>{{spec.Prefix}}</c> and 
              /// {{spec.RandomLength}} random alphanumeric ASCII characters.
              /// </summary>
              public static {{spec.StructName}} NewId()
              {
                  byte[] identifier = new byte[Length];
                  
                  Prefix.CopyTo(identifier);
                  identifier[PrefixLength] = (byte)'_';

                  global::System.Security.Cryptography.RandomNumberGenerator.GetItems(
                      ValidIdBytes,
                      identifier.AsSpan(PrefixLength + 1));

                  return new {{spec.StructName}}(new global::System.ReadOnlyMemory<byte>(identifier));
              }
              """);

        return builder;
    }
}
