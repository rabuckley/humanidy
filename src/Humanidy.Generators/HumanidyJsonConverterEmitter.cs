using Microsoft.CodeAnalysis.Text;

namespace Humanidy.Generators;

internal static class HumanidyJsonConverterEmitter
{
    public static SourceText Emit(
        IdentifierSpecification spec,
        HumanidyCompilationOptions options)
    {
        var builder = new SourceWriter();

        builder.WriteBlock("// <auto-generated/>");

        builder.WriteBlock("#nullable enable");

        builder.WriteBlock("namespace Humanidy.Text.Json;");

        builder.WriteLine(
            $$"""
              public sealed class {{spec.StructName}}JsonConverter : global::System.Text.Json.Serialization.JsonConverter<{{spec.FullyQualifiedStructName}}>
              {
              """);

        builder.Indentation++;

        builder.WriteBlock(
            $$"""
              public override {{spec.FullyQualifiedStructName}} Read(
                  ref global::System.Text.Json.Utf8JsonReader reader, 
                  global::System.Type typeToConvert, 
                  global::System.Text.Json.JsonSerializerOptions options)
              {
                  if (reader.TokenType is not global::System.Text.Json.JsonTokenType.String)
                  {
                      throw new global::System.Text.Json.JsonException("Expected a string token.");
                  }
                  
                  var valueLength = reader.HasValueSequence
                      ? checked((int)reader.ValueSequence.Length)
                      : reader.ValueSpan.Length;
                  
                  if (valueLength is not {{spec.FullyQualifiedStructName}}.Length)
                  {
                        throw new global::System.Text.Json.JsonException(
                            $"Expected a {{spec.StructName}} value of length {{spec.TotalLength}}, but got '{valueLength}'.");
                  }
                  
                  global::System.Span<byte> buffer = stackalloc byte[{{spec.FullyQualifiedStructName}}.Length];
                  var bytesWritten = reader.CopyString(buffer);
                  global::System.Diagnostics.Debug.Assert(bytesWritten is {{spec.FullyQualifiedStructName}}.Length);
                 
                  if (!{{spec.FullyQualifiedStructName}}.TryParse(buffer, out var result))
                  {
                      throw new global::System.Text.Json.JsonException($"Invalid {{spec.StructName}}.");
                  }

                  return result;
              }
              """);

        builder.WriteSkipLocalsInitAttr(options);

        builder.WriteBlock(
            $$"""
              public override void Write(
                  global::System.Text.Json.Utf8JsonWriter writer, 
                  {{spec.FullyQualifiedStructName}} value, 
                  global::System.Text.Json.JsonSerializerOptions options)
              {
                  global::System.Span<byte> buffer = stackalloc byte[{{spec.FullyQualifiedStructName}}.Length];
                  
                  if (!value.TryFormat(buffer, out var bytesWritten))
                  {
                      ThrowFailedToFormatException();
                      return;
                  }
                
                  writer.WriteStringValue(buffer[..bytesWritten]);
              }
              """);

        builder.WriteSkipLocalsInitAttr(options);

        builder.WriteBlock(
            $$"""
              public override void WriteAsPropertyName(
                  global::System.Text.Json.Utf8JsonWriter writer, 
                  {{spec.FullyQualifiedStructName}} value, 
                  global::System.Text.Json.JsonSerializerOptions options)
              {
                  global::System.Span<byte> buffer = stackalloc byte[{{spec.FullyQualifiedStructName}}.Length];
                  
                  if (!value.TryFormat(buffer, out var bytesWritten))
                  {
                      ThrowFailedToFormatException();
                      return;
                  }
                
                  writer.WritePropertyName(buffer[..bytesWritten]);
              }
              """);


        builder.WriteBlock(
            $$"""
              private static void ThrowFailedToFormatException()
              {
                  throw new global::System.Text.Json.JsonException(
                      "Failed to format value as {{spec.FullyQualifiedStructName}}.");
              }
              """);

        builder.Indentation--;
        builder.WriteBlock("}");

        return builder.ToSourceText();
    }
}
