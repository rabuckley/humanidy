using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Humanidy.Generators;

internal static class HumanidyEmitter
{
    public static void Execute(
        SourceProductionContext context,
        (Compilation Left, ImmutableArray<IdentifierSpecification> Right) data)
    {
        var (compilation, specifications) = data;

        // If there are no specifications, do nothing.
        if (specifications.IsDefaultOrEmpty)
        {
            return;
        }

        // Generate code for each specification.
        GenerateCode(context, compilation, specifications);
    }

    /// <summary>
    /// Gets the entropy in bits of an identifier with the given length and alphabet size.
    /// The entropy is calculated as <c>length * log2(alphabetSize)</c>.
    /// </summary>
    /// <param name="length">The length of the randomly-generated string.</param>
    /// <param name="alphabetSize">The length of the alphabet used to generate the string.</param>
    /// <returns>The entropy in bits.</returns>
    private static double Entropy(int length, int alphabetSize)
    {
        return length * Math.Log(alphabetSize, 2);
    }

    private static void GenerateCode(
        SourceProductionContext context,
        Compilation compilation,
        ImmutableArray<IdentifierSpecification> specifications)
    {
        // Go through all filtered class declarations.
        foreach (var spec in specifications)
        {
            var anyErrors = false;

            foreach (var diagnostic in spec.Diagnostics)
            {
                context.ReportDiagnostic(diagnostic);

                // Use effective severity, rather than defaults.
                if (diagnostic.Severity is DiagnosticSeverity.Error)
                {
                    anyErrors = true;
                }
            }

            if (anyErrors)
            {
                // If there are any errors, skip generating code for this specification.
                continue;
            }

            const string alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
            var entropy = Entropy(spec.RandomLength, alphabet.Length);

            var builder = new StringBuilder();

            builder.AppendLine("// <auto-generated/>");
            builder.AppendLine();
            builder.AppendLine("#nullable enable");
            builder.AppendLine();

            if (spec.Namespace is not null)
            {
                builder.AppendLine($"namespace {spec.Namespace};");
                builder.AppendLine();
            }

            var jsonSerializerTypeFullName = $"global::Humanidy.Text.Json.{spec.StructName}JsonConverter";
            
            var length = spec.Prefix.Length + spec.RandomLength + 1; // +1 for the underscore

            /*language=cs*/
            var code = $$"""
                         /// <summary>
                         /// An identifier of the form <c>{{spec.Prefix}}_</c> followed by {{spec.RandomLength}} random alphanumeric ASCII characters.
                         /// <remarks>
                         /// {{spec.StructName}} has an entropy of ~{{entropy:F2}} bits.
                         /// </remarks>
                         /// </summary>
                         // [global::System.Text.Json.Serialization.JsonConverter(typeof({{jsonSerializerTypeFullName}}))]
                         readonly partial struct {{spec.StructName}} :
                            global::System.IEquatable<{{spec.StructName}}>,
                            global::System.IComparable<{{spec.StructName}}>,
                            global::System.ISpanFormattable,
                            global::System.ISpanParsable<{{spec.StructName}}>,
                            global::System.IUtf8SpanFormattable,
                            global::System.IUtf8SpanParsable<{{spec.StructName}}>
                         {
                             private const int MaxRandomLength = 256;
                             private const int RandomLength = {{spec.RandomLength}};
                             private const int PrefixLength = {{spec.Prefix.Length}};
                             
                             private static global::System.ReadOnlySpan<byte> ValidIdBytes => "{{alphabet}}"u8;
                             
                             private static global::System.ReadOnlySpan<byte> Prefix => "{{spec.Prefix}}"u8;
                             
                             /// <summary>
                             /// The length of the identifier when not empty.
                             /// </summary>
                             public const int Length = {{length}};

                             private readonly global::System.ReadOnlyMemory<byte> _value;
                             
                             private {{spec.StructName}}(global::System.ReadOnlyMemory<byte> value)
                             {
                                 _value = value;
                             }
                             
                             /// <summary>
                             /// Creates a new, randomly generated, {{spec.StructName}} with the prefix <c>{{spec.Prefix}}</c> and {{spec.RandomLength}} random alphanumeric ASCII characters.
                             /// </summary>
                             public static {{spec.StructName}} NewId()
                             {
                                 global::System.Memory<byte> buffer = new byte[Length];
                                 
                                 Prefix.CopyTo(buffer.Span);
                                 buffer.Span[PrefixLength] = (byte)'_';

                                 global::System.Security.Cryptography.RandomNumberGenerator.GetItems(ValidIdBytes, buffer.Span[(PrefixLength + 1)..]);

                                 return new(buffer);
                             }
                                 
                             public bool Equals({{spec.StructName}} other)
                             {
                                 return global::System.MemoryExtensions.SequenceEqual(_value.Span, other._value.Span);
                             }
                             
                             public override bool Equals(object? obj)
                             {
                                 return obj is {{spec.StructName}} identifier && Equals(identifier);
                             }
                             
                             public override int GetHashCode()
                             {
                                 var c = new global::System.HashCode();
                                 c.AddBytes(_value.Span);
                                 return c.ToHashCode();
                             }
                             
                             public static bool operator ==({{spec.StructName}} left, {{spec.StructName}} right)
                             {
                                 return left.Equals(right);
                             }
                             
                             public static bool operator !=({{spec.StructName}} left, {{spec.StructName}} right)
                             {
                                 return !(left == right);
                             }

                             public int CompareTo({{spec.StructName}} other)
                             {
                                 return global::System.MemoryExtensions.SequenceCompareTo(_value.Span, other._value.Span);
                             }
                             
                             public static bool operator <({{spec.StructName}} left, {{spec.StructName}} right)
                             {
                                 return left.CompareTo(right) < 0;
                             }
                             
                             public static bool operator <=({{spec.StructName}} left, {{spec.StructName}} right)
                             {
                                 return left.CompareTo(right) <= 0;
                             }
                             
                             public static bool operator >({{spec.StructName}} left, {{spec.StructName}} right)
                             {
                                 return left.CompareTo(right) > 0;
                             }
                             
                             public static bool operator >=({{spec.StructName}} left, {{spec.StructName}} right)
                             {
                                 return left.CompareTo(right) >= 0;
                             }
                             
                             # region IParsable<{{spec.StructName}}>
                             
                             public static {{spec.StructName}} Parse(string s)
                             {
                                 global::System.ArgumentNullException.ThrowIfNull(s);
                                 return Parse(global::System.MemoryExtensions.AsSpan(s));
                             }

                             static {{spec.StructName}} global::System.IParsable<{{spec.StructName}}>.Parse(string s, global::System.IFormatProvider? provider)
                             {
                                 return Parse(s);
                             }

                             public static bool TryParse(string? s, out {{spec.StructName}} result)
                             {
                                 if (s is null)
                                 {
                                     result = default;
                                     return false;
                                 }

                                 return TryParse(global::System.MemoryExtensions.AsSpan(s), out result);
                             }

                             static bool global::System.IParsable<{{spec.StructName}}>.TryParse(string? s, global::System.IFormatProvider? provider, out {{spec.StructName}} result)
                             {
                                 return TryParse(s, out result);
                             }

                             # endregion
                             
                             public override string ToString()
                             {
                                 if (_value.IsEmpty)
                                 {
                                     return string.Empty;
                                 }
                                 
                                 return string.Create(Length, this, static (span, @self) =>
                                 {
                                     var result = @self.TryFormat(span, out var charsWritten);
                                     global::System.Diagnostics.Debug.Assert(result);
                                     global::System.Diagnostics.Debug.Assert(charsWritten == Length);
                                 });
                             }
                             
                             string global::System.IFormattable.ToString(
                                 string? format, 
                                 global::System.IFormatProvider? formatProvider)
                             {
                                 return ToString();
                             }

                             # region ISpanParsable<{{spec.StructName}}>

                             public static {{spec.StructName}} Parse(global::System.ReadOnlySpan<char> s)
                             {
                                 if (TryParse(s, out var result))
                                 {
                                     return result;
                                 }
                                 
                                 throw new global::System.FormatException(
                                     $"The provided string '{s.ToString()}' is not a valid {{spec.StructName}}.");
                             }

                             static {{spec.StructName}} global::System.ISpanParsable<{{spec.StructName}}>.Parse(global::System.ReadOnlySpan<char> s, global::System.IFormatProvider? provider)
                             {
                                 return Parse(s);
                             }

                             public static bool TryParse(global::System.ReadOnlySpan<char> s, out {{spec.StructName}} result)
                             {
                                 global::System.Span<byte> buffer = stackalloc byte[Length];

                                 if (global::System.Text.Ascii.FromUtf16(s, buffer, out var bytesWritten) is global::System.Buffers.OperationStatus.Done)
                                 {
                                     return TryParse(buffer[..bytesWritten], out result);
                                 }

                                 result = default;
                                 return false;
                             }
                            
                             static bool global::System.ISpanParsable<{{spec.StructName}}>.TryParse(global::System.ReadOnlySpan<char> s, global::System.IFormatProvider? provider, out {{spec.StructName}} result)
                             {
                                 return TryParse(s, out result);
                             }
                            
                             # endregion
                             
                             # region IUtf8SpanParsable<{{spec.StructName}}>
                             
                             public static {{spec.StructName}} Parse(global::System.ReadOnlySpan<byte> utf8Text)
                             {
                                 if (TryParse(utf8Text, out var result))
                                 {
                                     return result;
                                 }
                                
                                 throw new global::System.FormatException(
                                     $"The provided UTF-8 byte span is not a valid {{spec.StructName}}.");
                             }
                             
                             static {{spec.StructName}} global::System.IUtf8SpanParsable<{{spec.StructName}}>.Parse(global::System.ReadOnlySpan<byte> utf8Text, global::System.IFormatProvider? provider)
                             {
                                 return Parse(utf8Text);
                             }
                             
                             public static bool TryParse(global::System.ReadOnlySpan<byte> utf8Text, out {{spec.StructName}} result)
                             {
                                 if (utf8Text.Length is not Length || utf8Text[PrefixLength] is not (byte)'_')
                                 {
                                     result = default;
                                     return false;
                                 }
                                    
                                 for (var i = 0; i < PrefixLength; i++)
                                 {
                                     if (utf8Text[i] != Prefix[i])
                                     {
                                         result = default;
                                         return false;
                                     }
                                 }

                                 result = new(utf8Text.ToArray());
                                 return true;
                             }
                                
                             static bool global::System.IUtf8SpanParsable<{{spec.StructName}}>.TryParse(global::System.ReadOnlySpan<byte> utf8Text, global::System.IFormatProvider? provider, out {{spec.StructName}} result)
                             {
                                 return TryParse(utf8Text, out result);
                             }
                             
                             # endregion
                             
                             # region ISpanFormattable
                             
                             public bool TryFormat(
                                 global::System.Span<char> destination, 
                                 out int charsWritten)
                             {
                                 if (destination.Length < Length)
                                 {
                                     charsWritten = 0;
                                     return false;
                                 }

                                 return global::System.Text.Ascii.ToUtf16(_value.Span, destination, out charsWritten) is global::System.Buffers.OperationStatus.Done;
                             }
                             
                             bool global::System.ISpanFormattable.TryFormat(
                                 global::System.Span<char> destination, 
                                 out int charsWritten, 
                                 global::System.ReadOnlySpan<char> format, 
                                 global::System.IFormatProvider? provider)
                             {
                                 return TryFormat(destination, out charsWritten);
                             }
                             
                             # endregion
                             
                             # region IUtf8SpanFormattable
                             
                             public bool TryFormat(global::System.Span<byte> utf8Destination, out int bytesWritten)
                             {
                                 if (utf8Destination.Length < Length)
                                 {
                                     bytesWritten = 0;
                                     return false;
                                 }

                                 _value.Span.CopyTo(utf8Destination);
                                 bytesWritten = _value.Length;
                                 return true;
                             }
                             
                             bool global::System.IUtf8SpanFormattable.TryFormat(
                                 global::System.Span<byte> utf8Destination, 
                                 out int bytesWritten, 
                                 global::System.ReadOnlySpan<char> format, 
                                 global::System.IFormatProvider? provider)
                             {
                                 return TryFormat(utf8Destination, out bytesWritten);
                             }
                             
                             # endregion
                         }
                         """;

            builder.AppendLine(code);

            var fullyQualifiedStructName = spec.Namespace is null
                ? $"global::{spec.StructName}"
                : $"global::{spec.Namespace}.{spec.StructName}";

            var jsonSerializerBuilder = new StringBuilder();

            jsonSerializerBuilder.AppendLine("// <auto-generated/>");
            jsonSerializerBuilder.AppendLine();

            jsonSerializerBuilder.AppendLine("#nullable enable");
            jsonSerializerBuilder.AppendLine();

            jsonSerializerBuilder.AppendLine("namespace Humanidy.Text.Json;");
            jsonSerializerBuilder.AppendLine();

            jsonSerializerBuilder.AppendLine(
                /*language=cs*/
                $$"""
                  public sealed class {{spec.StructName}}JsonConverter : global::System.Text.Json.Serialization.JsonConverter<{{fullyQualifiedStructName}}>
                  {
                      public override {{fullyQualifiedStructName}} Read(ref global::System.Text.Json.Utf8JsonReader reader, global::System.Type typeToConvert, global::System.Text.Json.JsonSerializerOptions options)
                      {
                          if (reader.TokenType != global::System.Text.Json.JsonTokenType.String)
                          {
                              throw new global::System.Text.Json.JsonException("Expected a string token.");
                          }

                          var value = reader.GetString();
                         
                          if (value is null || !{{fullyQualifiedStructName}}.TryParse(value, out var result))
                          {
                              throw new global::System.Text.Json.JsonException($"Invalid {{fullyQualifiedStructName}} value: {value}");
                          }

                          return result;
                      }

                      public override void Write(global::System.Text.Json.Utf8JsonWriter writer, {{fullyQualifiedStructName}} value, global::System.Text.Json.JsonSerializerOptions options)
                      {
                          writer.WriteStringValue(value.ToString());
                      }
                  }                   
                  """);

            // Add the source code to the compilation.
            context.AddSource($"{spec.StructName}.g.cs", SourceText.From(builder.ToString(), Encoding.UTF8));

            context.AddSource($"{spec.StructName}JsonConverter.g.cs",
                SourceText.From(jsonSerializerBuilder.ToString(), Encoding.UTF8));
        }
    }
}
